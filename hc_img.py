# -*- coding: utf-8 -*-
"""Huffman.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1E3LSFHEXBMLU8nXAjlZu6p3sCBurOZmt
"""

# -*- coding: utf-8 -*-

import numpy as np
import cv2
import os
import time
from skimage import metrics

# Node of a Huffman Tree
class Nodes:
    def __init__(self, probability, symbol, left=None, right=None):
        self.probability = probability
        self.symbol = symbol
        self.left = left
        self.right = right
        self.code = ''

# Calculate the probabilities of symbols in the data
def CalculateProbability(data):
    symbols = dict()
    for item in data:
        if item not in symbols:
            symbols[item] = 1
        else:
            symbols[item] += 1
    return symbols

# Calculate the codes of symbols by traversing the Huffman Tree
def CalculateCodes(node, value='', codes=None):
    if codes is None:
        codes = dict()
    newValue = value + str(node.code)
    if node.left:
        CalculateCodes(node.left, newValue, codes)
    if node.right:
        CalculateCodes(node.right, newValue, codes)
    if not node.left and not node.right:
        codes[node.symbol] = newValue
    return codes

# Get the encoded result
def OutputEncoded(data, coding):
    encodingOutput = [coding[element] for element in data]
    encoded_string = ''.join(encodingOutput)
    with open('encoded_file.bin', 'w') as file:
        file.write(encoded_string)
    print("Encoded file has been saved successfully as 'encoded_file.bin'")

# Huffman Encoding
def HuffmanEncoding(data):
    symbolWithProbs = CalculateProbability(data)
    the_symbols = symbolWithProbs.keys()
    the_nodes = [Nodes(symbolWithProbs[symbol], symbol) for symbol in the_symbols]

    while len(the_nodes) > 1:
        the_nodes = sorted(the_nodes, key=lambda x: x.probability)
        left, right = the_nodes[0], the_nodes[1]
        left.code, right.code = 0, 1
        newNode = Nodes(left.probability + right.probability, left.symbol + right.symbol, left, right)
        the_nodes = the_nodes[2:]  # Remove the two smallest nodes
        the_nodes.append(newNode)

    huffmanEncoding = CalculateCodes(the_nodes[0])
    OutputEncoded(data, huffmanEncoding)

    with open('encoded_file.bin', 'r') as file:
        encodedOutput = file.read()

    return encodedOutput, the_nodes[0]

# Huffman Decoding
def HuffmanDecoding(encodedData, huffmanTree):
    treeHead = huffmanTree
    decodedOutput = []
    for x in encodedData:
        huffmanTree = huffmanTree.right if x == '1' else huffmanTree.left
        if not huffmanTree.left and not huffmanTree.right:
            decodedOutput.append(huffmanTree.symbol)
            huffmanTree = treeHead
    return decodedOutput

def main():
    # Start timing
    start_time = time.time()

    # Load the image
    image_path = '/content/Farewell Party_20240609_185525_0000.png'
    img = cv2.imread(image_path)
    pixel_values_array = img.ravel()
    pixel_values = pixel_values_array.tolist()

    # Huffman Encoding
    encoded_output, the_tree = HuffmanEncoding(pixel_values)

    # Huffman Decoding
    Decoded_Output = np.array(HuffmanDecoding(encoded_output, the_tree))
    restored_img = Decoded_Output.reshape(img.shape)

    # Save the restored image
    saved_image_path = 'restored.jpg'
    cv2.imwrite(saved_image_path, restored_img)
    print("Restored image has been saved as:", saved_image_path)

    # Check if the compression is lossless
    if np.array_equal(pixel_values_array, Decoded_Output):
        print("This Huffman coding code is doing a Lossless compression")
    else:
        print("This Huffman coding code is not doing a Lossless compression")

    # Image quality metrics
    reference_size = os.path.getsize(image_path)
    restored_size = os.path.getsize(saved_image_path)
    compression_ratio = reference_size / restored_size
    print('Compression Ratio:', compression_ratio)

    mse = metrics.mean_squared_error(img, restored_img)
    print("MSE:", mse)

    if mse != 0:
        psnr = metrics.peak_signal_noise_ratio(img, restored_img, data_range=None)
        print("PSNR:", psnr)
    else:
        print("PSNR: infinity")

    # End timing
    end_time = time.time()
    total_time = end_time - start_time
    print(f"Total time taken: {total_time} seconds")

if __name__ == "__main__":
    main()